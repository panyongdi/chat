## String、StringBuffer和StringBuilder

​	String是使用final修饰。不可变，每次操作都会生成新的String对象

​	StringBuffer和StringBuilder线程不安全的，StringBuffer的方法都是使用synchronized修饰

```java
性能比较：StringBuilder>StringBuffer>String
```

在通常情况下，优先使用StringBuilder，在多线程共享变量时使用StringBuffer

## 重载和重写的区别

​	重载：发生在同一个类中，方法名必须相同，参数类型不同、格式不同、顺序不同、方法返回值不同，发生在编译时

​	重写：发生在父子类中，方法名跟参数列表必须相同，返回值范围小于父类，访问修饰符范围大于等于父类，如果父类方法修饰符为private则子类不能重新该方法。

## 接口和抽象区别

- 抽象类可以存在普通成员变量，接口中只能存在public abstract方法

- 抽象类的成员变量可以是各种类型的，二接口中的成员变量只能是publice static final类型

- 抽象类只能继承一个，接口可以实现多个

  

抽象类的设计目的是代码复用，当不同的类具有相同的行为(行为集合A)，且一部分行为的事项方法一致时（A的非真子集 B），可以让这些类都派生于一个抽象了，在这个抽象了中实现B，避免让所有的子类来实现，达到代码服务的目的。而A-B的部分，留给各子类自己实现，正是因为A-B在这里没有实现，所以抽象了不允许实例化出来。

接口的设计目的是对类的行为进行约束(是一个中”有"约束,接口不能规定类不允许有什么行为)，就是提供一种机制，可以强制要求不同的类具有相同的行为，只能约束行为的有无，但不对如何实现行为进行限制。

抽象类是对类本质的抽象，表达的是 is a 的关系。抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。

而接口时对行为的抽象，表达的是like a的关系，接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、是如何实现的，接口并不关心。

当关注事务的本质的时候用抽象类，当关注一个操作的时候，用接口。

抽象类功能远超过接口，但定义抽象类的代价高，在这个类中必须继承或编写其所有子类的所有共性，虽然接口功能上会弱化很多，但它只是针对一个动作的描述，而且可以在一个类中同时实现多个接口，降低难度。

## hashCode与equals

hashCode作用是获取哈希码。作用是确定该对象在哈希表中的索引位置。 

equals是用来比较两个对象是否相同。

hashCode能减少equals的次数，提升执行速度。

- 当两个对象相等时，则hashcode一定相同的

- 两个对象相等，对两个对象分别调用equals都返回true

- 两个对象有相同的hashcode值，他们不一定是相等的

- equals方法被覆盖过，则hashcode也必须被覆盖

- hashcode的默认行为是对堆上的对象产生独特值，如果没有重写hashcode，则该class的两个对象无论如何都不会相等，即是两个对象指向相同的数据

  

## ArrayList和LinkedList区别

ArrayList：基于动态数组，连续内存存储，适合下表访问，扩容机制：因为数组长度固定，超出长度存数据时需要新建数组，然后将老数组拷贝到新数组，如果不是尾部插入数据还好涉及元素的访问，使用尾插法并指定初始容量值可以极大提升性能

LinkList：基于链表，可以存储在分散的内存中，适合做数据的插入以及删除，不适合查询，需要足以变量LinkedList必须使用iterator不能使用for循环

同时不用使用indexOf等返回元素索引，并对其进行变量，使用indexOf堆list进行遍历，当结果为空时会遍历整个列表。

## HashMap

HashMap底层实现：数组+链表实现

1.8之后链表高德达到8、数组长度超过64，链表转成红黑树，元素已内部Node节点存在

- 计算key的hash值，二次hash然后堆数组长度取模，对应到数组下标
- 如果没有产生hash冲突，则直接创建Node存入数组
- 如果产生hash冲突，先进行equals比较，相同则取代该元素，不同，则判断链表高度插入链表，链表高德达到0，并且数组长度到64则变为红黑树，长度低于6则将红黑树转会链表
- key位null，存在下标0的位置

## ConcurrentHashMap原理



jdk 7：

数据结构： ReentrantLock+Segment+HashEntry，一个Segment中包含一个HashEnttry数组。每个HashEntry又是一个链表结构

元素查询：二次hash，第一个hash定位Segment，第二次Hash定位到元素所在的链表的头部

苏：sefment分段锁，Segment继承ReentrantLock，锁定操作的Segment，其他的Segment不受影响，并发度位segment个数，通过构造函数指定，数组扩容不会影响其他的segment

jdk8.0：

数据结构：synchronized+CAS+Node——红黑树，Node的val和next都用volatile修饰，保证可见性

查找，替换，赋值操作都是用CAS

锁：锁链表的head节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有的读写操作、并非扩容

读操作无锁

## IOC容器的实现

1. 配置文件配置包扫描路径
2. 递归包扫描获取class文件
3. 反射、确定需要交给ioc管理的类
4. 对需要注入的类惊醒依赖注入

## 字节码

供虚拟机理解的代码叫做字节码（.class文件）

java源程序通过编译器编码成字节码，字节码有虚拟机解释执行，虚拟机将每一个条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后再特定的机器上运行。因此java是编译跟解释并存的特点。

采用字节码能够在一定程度上解决了传统解释型语言执行效率地的问题，同时保存了解释型语言可移植的特点，无需重新编译，实现跨平台运行。

## java类加载器

jdk自带三个类加载器：bootstrap classLoader，ExtClassLoader和AppClassLoader

bootstrap classLoader是ExtClassLoader的父类加载器，默认负责加载%java_home%/lib下的jar包和class文件

ExtClassLoader是AppClassLoader的父类加载器，负责加载%java_home%/lib、ext文件夹下的jar包和class类

AppClassLoader是自定义类加载器的父类，负责加载classpath下的类文件，即是系统类加载器又是线程上下文加载器

继承appClassLoader实现自定义类加载器

